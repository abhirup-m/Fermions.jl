<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick-Start: Installation and a Concrete Example · Fermions.jl</title><meta name="title" content="Quick-Start: Installation and a Concrete Example · Fermions.jl"/><meta property="og:title" content="Quick-Start: Installation and a Concrete Example · Fermions.jl"/><meta property="twitter:title" content="Quick-Start: Installation and a Concrete Example · Fermions.jl"/><meta name="description" content="Documentation for Fermions.jl."/><meta property="og:description" content="Documentation for Fermions.jl."/><meta property="twitter:description" content="Documentation for Fermions.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Fermions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Fermions.jl</a></li><li><a class="tocitem" href="../base/">Base - Working with States and Operators</a></li><li><a class="tocitem" href="../correlations/">Correlations - Computing Observables and Other Analyses</a></li><li><a class="tocitem" href="../eigen/">Eigen - Eigenfunction Solver and Related Methods</a></li><li class="is-active"><a class="tocitem" href>Quick-Start: Installation and a Concrete Example</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension"><span>Defining our Model - The Tight-Binding Model in One Dimension</span></a></li><li><a class="tocitem" href="#Importing-Packages"><span>Importing Packages</span></a></li><li><a class="tocitem" href="#Defining-Basis-States"><span>Defining Basis States</span></a></li><li><a class="tocitem" href="#Creating-the-Hamiltonian"><span>Creating the Hamiltonian</span></a></li><li><a class="tocitem" href="#Calculating-Correlations:-Local-Probability-Distribution"><span>Calculating Correlations: Local Probability Distribution</span></a></li><li><a class="tocitem" href="#Real-space-Entanglement"><span>Real-space Entanglement</span></a></li><li><a class="tocitem" href="#Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature"><span>Finite Temperature Calculations: Local Probability Distribution as a Function of Temperature</span></a></li><li><a class="tocitem" href="#Spectral-Function"><span>Spectral Function</span></a></li></ul></li><li><a class="tocitem" href="../theory/">Theoretical Background - Fermions, Symmetries and Second Quantisation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick-Start: Installation and a Concrete Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick-Start: Installation and a Concrete Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/abhirup-m/Fermions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/abhirup-m/Fermions.jl/blob/master/docs/src/quickstart.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start:-Installation-and-a-Concrete-Example"><a class="docs-heading-anchor" href="#Quick-Start:-Installation-and-a-Concrete-Example">Quick-Start: Installation and a Concrete Example</a><a id="Quick-Start:-Installation-and-a-Concrete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start:-Installation-and-a-Concrete-Example" title="Permalink"></a></h1><p>This write-up is designed to show you very quickly how to start using this toolkit. It demonstrates the typical kind of calculations that are possible using the fermions.jl library. </p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The system must have a running Julia installation in order to use fermions.jl:</p><pre><code class="language-console hljs"># install Julia on Unix-ish systems
$ curl -fsSL https://install.julialang.org | sh

# install Julia on windows
&gt; winget install julia -s msstore</code></pre><p>Once a running Julia environment is available, start the Julia REPL by running <code>julia</code> from a terminal, and run the following commands to install the fermions.jl library:</p><pre><code class="language-julia hljs">julia&gt; import Pkg
julia&gt; Pkg.add(url=&quot;https://github.com/abhirup-m/fermions.jl&quot;)</code></pre><h2 id="Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension"><a class="docs-heading-anchor" href="#Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension">Defining our Model - The Tight-Binding Model in One Dimension</a><a id="Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension" title="Permalink"></a></h2><p>The model considered here is a prototypical one, involving spinless electrons hopping on a 1D lattice, with open boundary conditions (the electrons cannot hop beyond the left and right edges of the chain).</p><p><img src="../examples/images/tbm1D.svg" alt/> <em>Schematic picture of the model being considered here. Circles represent lattice sites and arrows represent electron hopping processes across sites.</em></p><p>The Hamiltonian of the model is very simple; there are only two kinds of processes - one that starts from a lattice site <span>$i$</span> and goes to the site next to it (<span>$i+1$</span>), and another one that goes to the site before it (<span>$i-1$</span>). In terms of operators, the Hamiltonian can be written as</p><p class="math-container">\[H = \sum_i \left(c^\dagger_i c_{i+1} + c^\dagger_{i+1}c_i\right)~.\]</p><p>In this write-up, we will now show how to accomplish the following:</p><ul><li><p>Define the above Hamiltonian and diagonalise it to obtain the spectrum.</p></li><li><p>Analyse the ground state and calculate the distribution of particles on the lattice in the ground state.</p></li><li><p>Calculate thermal correlation functions such as the local particle density at a non-zero temperature.</p></li><li><p>Calculate other useful quantities such as the entanglement of a region of space and the spectral function. </p></li></ul><p>This quick-start example is also available as a <a href="../examples/TightBinding1D.ipynb">notebook</a>.</p><h2 id="Importing-Packages"><a class="docs-heading-anchor" href="#Importing-Packages">Importing Packages</a><a id="Importing-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-Packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using fermions # Importing fermions.jl library
using Plots, Measures # Importing tools for plotting
Plots.theme(:dark)</code></pre><h2 id="Defining-Basis-States"><a class="docs-heading-anchor" href="#Defining-Basis-States">Defining Basis States</a><a id="Defining-Basis-States-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Basis-States" title="Permalink"></a></h2><p>Most applications of this libray require us to define a choice of basis states. The most convenient basis for us is the real space basis, consisting of states such <code>[1, 0, 1, 1, ..., 0, 1]</code>, where each number in the vector can be 0 or 1, and the <span>$i^\mathrm{th}$</span> number represents whether the <span>$i^\mathrm{th}$</span> lattice site is occupied(<code>1</code>) or unoccupied(<code>0</code>). Within the library, we define the basis states using the function BasisStates:</p><pre><code class="nohighlight hljs">basis = fermions.BasisStates(numSites, occupancy)</code></pre><p>Here, the first argument <code>numSites</code> is an <code>Int</code> that represents the number of lattice sites that must be taken into account while creating the basis, while the second (optional) argument <code>occupancy</code> is another <code>Int</code> which represents the number of occupied particles in the basis states. For example, if we choose <code>basis = fermions.BasisStates(2, 1)</code>, that will return the basis states involving two lattice sites and one electron occupying those sites, leading to the basis <code>[1, 0], [0, 1]</code>.</p><pre><code class="language-julia hljs">numSites = 2 # number of lattice sites
occupancy = 1
basis = fermions.BasisStates(numSites, occupancy) </code></pre><pre><code class="nohighlight hljs">2-element Vector{Dict{BitVector, Float64}}:
 Dict([1, 0] =&gt; 1.0)
 Dict([0, 1] =&gt; 1.0)</code></pre><p>The two basis states show the two possible combinations: <code>[1, 0]</code> is the state with the first site occupied and the second site unoccupied, while <code>[0, 1]</code> has the opposite configuration.</p><h2 id="Creating-the-Hamiltonian"><a class="docs-heading-anchor" href="#Creating-the-Hamiltonian">Creating the Hamiltonian</a><a id="Creating-the-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Hamiltonian" title="Permalink"></a></h2><p>Any general second-quantised Hamiltonian can be represented, while using the library, as a 1D array. In order to explain how to create the Hamiltonian, we will start by giving a very simple example. The (non-Hermitian) Hamiltonian <span>$c^\dagger_1 c_2 - c^\dagger_3 c_4$</span> is represented as</p><pre><code class="nohighlight hljs">H = [
        (&quot;+-&quot;, [1, 2], 1.0),
        (&quot;+-&quot;, [3, 4], -1.0),
    ]</code></pre><p>Each tuple <code>(...)</code> within the array represents a term of the full Hamiltonian. The term <span>$c^\dagger_1 c_2$</span> is represented by the first tuple <code>(&quot;+-&quot;, [1, 2], 1.0)</code>; the string <code>&quot;+-&quot;</code> encodes the fact that the operator is a product of a creation operator(<code>+</code>) and an annihilation operator(<code>-</code>), the vector <code>[1,2]</code> indicates that the <code>+</code> and <code>-</code> operators act on the first and second indices within in each basis states, and the third (<code>Float</code>) <code>1.0</code> indicates the strength of this term. </p><p>The second tuple <code>(&quot;+-&quot;, [3, 4], -1.0)</code> can be understood as a representation of the second operator <span>$- c^\dagger_3 c_4$</span> in the same way.</p><pre><code class="language-julia hljs"># designing the tight-binding Hamiltonian
function TightBindHamiltonian(numSites)

    # define the array of tuples to store all terms in the Hamiltonian 
    hamiltonianTerms = Tuple{String, Vector{Int64}, Float64}[]

    # loop over all lattice sites (skip the end, because we have c^\dagger_i+1 
    for i in 1:numSites-1

        # the term c^\dagger_i c_i+1
        term1 = (&quot;+-&quot;, [i, i+1], 1.0)

        # the term c^\dagger_i+1 c_i
        term2 = (&quot;+-&quot;, [i+1, i], 1.0)

        # add both terms to the Hamiltonian
        push!(hamiltonianTerms, term1)
        push!(hamiltonianTerms, term2)
    end
    return hamiltonianTerms
end</code></pre><h2 id="Calculating-Correlations:-Local-Probability-Distribution"><a class="docs-heading-anchor" href="#Calculating-Correlations:-Local-Probability-Distribution">Calculating Correlations: Local Probability Distribution</a><a id="Calculating-Correlations:-Local-Probability-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Correlations:-Local-Probability-Distribution" title="Permalink"></a></h2><p>Correlations are expectation values of observable operators, computed in the ground state: <span>$\langle\Psi_\mathrm{gs}|\hat O|\Psi_\mathrm{gs}\rangle$</span>. Any such expectation value can be calculated using the function <code>GenCorrelation(state, operator)</code>, where <code>state</code> can be one of the eigenstates (where we want to compute the correlation), and <code>operator</code> has to be constructed in the same way as the Hamiltonian.</p><p>As another physically-motivated demonstration, we will now calculate the real-space distribution of the ground state function, which is just the likelyhood of finding the electron at a given point in space. The probablity distribution at the <span>$i^\mathrm{th}$</span> lattice point is the expectation value </p><p class="math-container">\[\langle\Psi_\mathrm{gs}|c^\dagger_i c_i |\Psi_\mathrm{gs}\rangle = \langle\Psi_\mathrm{gs}| \hat n_i |\Psi_\mathrm{gs}\rangle~,\]</p><p>where <span>$\hat n$</span> is a shorthand for <span>$c^\dagger c$</span>, and is called the number operator. The object <code>operator</code> for this can therefore be constructed as <code>operator=[(&quot;n&quot;, [i], 1.0)]</code>. The complete thing is shown below.</p><pre><code class="language-julia hljs"># get basis, Hamiltonian and eigenvectors.
numSites = 50
basis = fermions.BasisStates(numSites, 1)
hamiltonian = TightBindHamiltonian(numSites)
eigvals, eigvecs = fermions.Spectrum(hamiltonian, basis)

# Define the local density operator, which is just the number operator n_i at a site i. 
# Within the fermions.jl library, the number operator is represented using &quot;n&quot;, just as c
# and c^† are represented using &quot;-&quot; and &quot;+&quot;.
densityOperators = [[(&quot;n&quot;, [i], 1.0)] for i in 1:numSites]

# calculate the expectation value of the local density operator in the ground state 
# and a mid-spectrum state. the expectation value is calculated using an internal 
# function GenCorrelation(state, operator), which returns the quantity &lt;state|operator|state&gt;.
distribution_low = [fermions.GenCorrelation(eigvecs[1], operator) for operator in densityOperators]
distribution_mid = [fermions.GenCorrelation(eigvecs[div(numSites, 2)], operator) for operator in densityOperators]

Plots.scatter([distribution_low, distribution_mid], thickness_scaling=1.4, linewidth=3, legend=true,
        xlabel=&quot;odd lattice sites&quot;, ylabel=&quot;probability distribution&quot;, labels=[&quot;ground state&quot; &quot;excited state&quot;], margin=-1mm)</code></pre><p><img src="../examples/images/output_9_0.svg" alt/></p><h2 id="Real-space-Entanglement"><a class="docs-heading-anchor" href="#Real-space-Entanglement">Real-space Entanglement</a><a id="Real-space-Entanglement-1"></a><a class="docs-heading-anchor-permalink" href="#Real-space-Entanglement" title="Permalink"></a></h2><p>As a second demonstration of the physics, we calculate the entanglement entropy of real space regions. Entanglement entropy is a measure of entanglement, quantifying how much a region of space is &quot;connected&quot; to the other regions. The source of the connection is the presence of the hopping term in the hamiltonian; as the electron hops from one end of the system to the other, it carries information with it, leading to non-local connections between distant regions. <code>fermions.jl</code> provides several functions to calculate various entanglement measures such as the von Neumann entropy (<code>vnEntropy()</code>), mutual information (<code>mutInfo</code>) and tripartite information (<code>tripInfo</code>). For this model, we will just calculate the von Neumann entropy of any given lattice site <span>$i$</span>, through the function call <code>vnEntropy(state, [i])</code>, where <code>state</code> is as usual the ground state, and <code>[i]</code> indicates the set of indices whose entanglement entropy will be calculated. Since we want to calculate the entropy of just the <span>$i^\mathrm{th}$</span> site, the indices is a singleton set for us. </p><pre><code class="language-julia hljs"># define regions of space of increasing size
subsystemIndices = [[i] for i in 1:numSites]

# calculate entanglement entropy of these regions
SEE = [fermions.vnEntropy(eigvecs[1], indices) for indices in subsystemIndices]
Plots.plot(SEE, thickness_scaling=1.4, linewidth=3, legend=false,
        xlabel=&quot;lattice site&quot;, ylabel=&quot;entanglement entropy&quot;, margin=-1mm)</code></pre><p><img src="../examples/images/output_11_0.svg" alt/></p><h2 id="Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature"><a class="docs-heading-anchor" href="#Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature">Finite Temperature Calculations: Local Probability Distribution as a Function of Temperature</a><a id="Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature" title="Permalink"></a></h2><p>One can also calculate thermal averages using the library. Similar to the <code>GenCorrelation</code> function that computes expectation values in a particular state, the <code>ThermalAverage(eigvecs, eigvals, operator, beta)</code> function accepts the complete set of eigenvectors <span>$\{X_i\}$</span> and eigenvalues <span>$\{\varepsilon_i\}$</span>, an operator <span>$\hat O$</span> and an inverse temperature beta <span>$\beta$</span>, and calculates the thermal expectation value </p><p class="math-container">\[\sum_i e^{-\beta \varepsilon_i}\langle X_i | \hat O | X_i \rangle~.\]</p><p>In the snippet below, we compute the thermal average of two operators, the probability of occupying the left edge <span>$\hat n_1$</span>, and the probability of occupying the central site <span>$\hat n_{N/2}$</span>.</p><pre><code class="language-julia hljs"># define a range of temperatures to perform calculations at
invTempRange = 10 .^ range(-1, 2.5, 20)

# define the operators whose thermal average we wish to calculate
leftOccOperator = [(&quot;n&quot;, [1], 1.0)] # occupancy of left edge
centerOccOperator = [(&quot;n&quot;, [div(numSites, 2)], 1.0)] # occupancy of center

# calculate thermal averages over the given range of inverse temperature
leftOccAverage = [fermions.ThermalAverage(eigvecs, eigvals, leftOccOperator, beta) for beta in invTempRange]
centerOccAverage = [fermions.ThermalAverage(eigvecs, eigvals, centerOccOperator, beta) for beta in invTempRange]

Plots.plot(1 ./ invTempRange, [leftOccAverage, centerOccAverage];
    thickness_scaling=1.5, linewidth=3,
    xaxis=:log10, xlabel=&quot;temp. / \$\\Delta E\$&quot;, ylabel=&quot;local occupancy&quot;, 
    labels=[&quot;left edge&quot; &quot;center&quot;], leftmargin=-5mm, bottommargin=-3mm)</code></pre><p><img src="../examples/images/output_13_0.svg" alt/></p><h2 id="Spectral-Function"><a class="docs-heading-anchor" href="#Spectral-Function">Spectral Function</a><a id="Spectral-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Function" title="Permalink"></a></h2><p>As a final demonstration, we show how to calculate the local spectral function for the model. A spectral function <span>$A(\omega)$</span> captures the probability of exciting the ground state of a system into an excited electron with a particular excitation energy <span>$\omega$</span>; a higher value of the spectral function at a particular frequency indicates a higher likelihood of exciting the system by shedding light of that frequency. Formally, the spectral function associated with the excitation operator <span>$\hat O_1$</span> and the relaxation operator <span>$\hat O_2$</span> is defined as </p><p class="math-container">\[A(\omega) = -\frac{1}{\pi}\mathrm{Im}\left[\mathcal{F}_\omega(\langle \{\hat O_2(t),\hat O_1(0)\}\rangle)\right]~,\]</p><p>where <span>$\mathcal{F}_\omega(\cdot)$</span> is the Fourier transform.</p><p>The spectral function is calculated using the provided function <code>SpecFunc(eigvecs, eigvals, probe, probeDag, freqArr, broadening)</code>, where <code>eigvecs, eigvals</code> constitute the spectrum of the system, <code>probe</code> and <code>probeDag</code> are the excitation and relaxation operators <span>$\hat O_1$</span> and <span>$\hat O_2$</span>, <code>freqArr</code> is the set of frequency points at which the spectral function must be calculated, and <code>broadening</code> is the width of the Lorentzian that will be used to replace poles. For the snippet below, we have taken the local operators <span>$c_{N/2}$</span> and <span>$c^\dagger_{N/2}$</span> as the excitation and relaxation operators.</p><pre><code class="language-julia hljs">numSites = 40 # number of lattice sites

# Get basis states for a system with 0, 1 and 2 occupied sites.
# The ground state will be taken from the 1 occupied site system,
# but the excitations will take it to the other systems.
basis_N = fermions.BasisStates(numSites, 1)
basis_Nminus1 = fermions.BasisStates(numSites, 0)
basis_Nplus1 = fermions.BasisStates(numSites, 2)

# diagonalise all three systems
tightBindHam = TightBindHamiltonian(numSites)
eigvals_N, eigvecs_N = fermions.Spectrum(tightBindHam, basis_N)
eigvals_Nminus1, eigvecs_Nminus1 = fermions.Spectrum(tightBindHam, basis_Nminus1)
eigvals_Nplus1, eigvecs_Nplus1 = fermions.Spectrum(tightBindHam, basis_Nplus1)

# define the set of frequency points
freqArr = collect(range(-2.5, stop=2.5, step=0.01))

# define the excitation and relaxation operators
probe = [(&quot;-&quot;, [div(numSites, 2)], 1.0)]
probeDag = [(&quot;+&quot;, [div(numSites, 2)], 1.0)]

# get spectral function
specfunc = fermions.SpecFunc([eigvals_N; eigvals_Nminus1; eigvals_Nplus1], 
    [eigvecs_N; eigvecs_Nminus1; eigvecs_Nplus1], probe, probeDag, freqArr, 1e-2)

p = Plots.plot(freqArr, specfunc, thickness_scaling=1.5, linewidth=2, legend=false, 
    xlabel=&quot;frequency \$\\omega\$&quot;, ylabel=&quot;spectral function\$&quot;, margin=-2mm)
display(p)</code></pre><p><img src="../examples/images/output_15_0.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../eigen/">« Eigen - Eigenfunction Solver and Related Methods</a><a class="docs-footer-nextpage" href="../theory/">Theoretical Background - Fermions, Symmetries and Second Quantisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 23 December 2024 18:06">Monday 23 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
