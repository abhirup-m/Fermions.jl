var documenterSearchIndex = {"docs":
[{"location":"base/#Base-Working-with-States-and-Operators","page":"Base - Working with States and Operators","title":"Base - Working with States and Operators","text":"","category":"section"},{"location":"base/","page":"Base - Working with States and Operators","title":"Base - Working with States and Operators","text":"BasisStates(\n        numLevels::Int64, \n        totOccReq::Vector{Int64},\n        magzReq::Vector{Int64},\n        localCriteria::Function\n)\n\nTransformBit(qubit::Bool, operator::Char)\n\nApplyOperatorChunk(\n        opType::String,\n        opMembers::Vector{Int64},\n        opStrength::Float64,\n        incomingState::Dict{BitVector,Float64};\n        tolerance::Float64=1e-16\n    )\n\nApplyOperator(\n        operator::Vector{Tuple{String,Vector{Int64},Float64}},\n        incomingState::Dict{BitVector,Float64};\n        tolerance::Float64=1e-16\n    )\n\nOperatorMatrix(\n        basisStates::Vector{Dict{BitVector,Float64}},\n        operator::Vector{Tuple{String,Vector{Int64},Float64}}\n    )\n\nStateOverlap(\n        state1::Dict{BitVector,Float64}, \n        state2::Dict{BitVector,Float64}\n    )","category":"page"},{"location":"base/#fermions.BasisStates-Tuple{Int64, Vector{Int64}, Vector{Int64}, Function}","page":"Base - Working with States and Operators","title":"fermions.BasisStates","text":"BasisStates(numLevels, totOccReq, magzReq, localCriteria)\n\nCreates a set of basis states for the numLevels Fock states, having the required total occupancy and magnetization, and subject to any criteria imposed locally.\n\nExamples\n\njulia> BasisStates(2, [1], [0], x->true)\nDict{BitVector, Float64}[]\njulia> BasisStates(3, [1], [-1], x->true)\n1-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 1, 0] => 1.0)\njulia> BasisStates(4, [2], [0], x->true)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0, 1, 1] => 1.0)\n Dict([0, 1, 1, 0] => 1.0)\n Dict([1, 0, 0, 1] => 1.0)\n Dict([1, 1, 0, 0] => 1.0)\njulia> BasisStates(4, [2], [0], x->sum(x[1:2])==1)\n2-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 1, 1, 0] => 1.0)\n Dict([1, 0, 0, 1] => 1.0)\n\n\n\n\n\n","category":"method"},{"location":"base/#fermions.TransformBit-Tuple{Bool, Char}","page":"Base - Working with States and Operators","title":"fermions.TransformBit","text":"TransformBit(qubit, operator)\n\nApply the single qubit operator ('n', 'h', '+' or '-') on a single fock state.\n\nExamples\n\njulia> TransformBit(Bool(0), '+')\n(1, 1)\n\njulia> TransformBit(Bool(1), 'h')\n(1, 0)\n\njulia> TransformBit(Bool(1), '-')\n(0, 1)\n\n\n\n\n\n","category":"method"},{"location":"base/#fermions.ApplyOperatorChunk-Tuple{String, Vector{Int64}, Float64, Dict{BitVector, Float64}}","page":"Base - Working with States and Operators","title":"fermions.ApplyOperatorChunk","text":"ApplyOperatorChunk(opType, opMembers, opStrength, incomingState; tolerance)\n\nApply a single tensor product operator chunk (for eg., c^†1 c2 or n1 c^†3 c_4)  on a general state and return the new state.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0]) => 1.0, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 1.0\n  [0, 1] => -0.5\n\njulia> opType, opMembers, opStrength = (\"+-\", [1, 2], 0.1)\n(\"+-\", [1, 2], 0.1)\n\njulia> ApplyOperatorChunk(opType, opMembers, opStrength, state)\nDict{BitVector, Float64} with 1 entry:\n  [1, 0] => -0.05\n\n\n\n\n\n","category":"method"},{"location":"base/#fermions.ApplyOperator-Tuple{Vector{Tuple{String, Vector{Int64}, Float64}}, Dict{BitVector, Float64}}","page":"Base - Working with States and Operators","title":"fermions.ApplyOperator","text":"ApplyOperator(operator, incomingState; tolerance)\n\nExtends ApplyOperatorChunk() by applying a more general operator (consisting of multiple operator chunks) on a general state.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0]) => 1.0, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 1.0\n  [0, 1] => -0.5\n\njulia> operator = [(\"+-\", [1, 2], 0.1), (\"nh\", [2, 1], 1.0)]\n2-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"+-\", [1, 2], 0.1)\n (\"nh\", [2, 1], 1.0)\n\njulia> ApplyOperator(operator, state)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => -0.05\n  [0, 1] => -0.5\n\n\n\n\n\n","category":"method"},{"location":"base/#fermions.OperatorMatrix-Tuple{Vector{Dict{BitVector, Float64}}, Vector{Tuple{String, Vector{Int64}, Float64}}}","page":"Base - Working with States and Operators","title":"fermions.OperatorMatrix","text":"OperatorMatrix(basisStates, operator)\n\nReturn the matrix representation of the operator in the given basis.\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> operator = [(\"+-\", [1, 2], 0.5), (\"n\", [2], -1.0)]\n2-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"+-\", [1, 2], 0.5)\n (\"n\", [2], -1.0)\n\njulia> OperatorMatrix(basis, operator)\n4×4 Matrix{Float64}:\n 0.0   0.0  0.0   0.0\n 0.0  -1.0  0.0   0.0\n 0.0   0.5  0.0   0.0\n 0.0   0.0  0.0  -1.0\n\n\n\n\n\n","category":"method"},{"location":"base/#fermions.StateOverlap-Tuple{Dict{BitVector, Float64}, Dict{BitVector, Float64}}","page":"Base - Working with States and Operators","title":"fermions.StateOverlap","text":"StateOverlap(state1, state2)\n\nCompute the inner product ⟨state1|state2⟩.\n\nExamples\n\njulia> state1 = Dict(Bool.([1, 0]) => 1.0, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 1.0\n  [0, 1] => -0.5\n\njulia> state2 = Dict(Bool.([1, 1]) => 0.5, Bool.([0, 1]) => 0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 1] => 0.5\n  [0, 1] => 0.5\n\njulia> StateOverlap(state1, state2)\n-0.25\n\n\n\n\n\n","category":"method"},{"location":"eigen/#Eigen-Eigenfunction-Solver-and-Related-Methods","page":"Eigen - Eigenfunction Solver and Related Methods","title":"Eigen - Eigenfunction Solver and Related Methods","text":"","category":"section"},{"location":"eigen/","page":"Eigen - Eigenfunction Solver and Related Methods","title":"Eigen - Eigenfunction Solver and Related Methods","text":"ClassifyBasis(\n        basisStates::Vector{Dict{BitVector,Float64}},\n        symmetries::Vector{Char};\n        energies::Vector{Float64}=Float64[],\n    )\n\nTransformState(\n        vector::Vector{Float64},\n        basisStates::Vector{Dict{BitVector,Float64}};\n        tolerance::Float64=1e-16,\n    )\n\nSpectrum(\n    operator::Vector{Tuple{String,Vector{Int64},Float64}},\n    basisStates::Vector{Dict{BitVector,Float64}};\n    diagElements::Vector{Float64}=Float64[],\n    tolerance::Float64=1e-16,\n    )\n\nSpectrum(\n    operator::Vector{Tuple{String,Vector{Int64},Float64}},\n    basisStates::Vector{Dict{BitVector,Float64}},\n    symmetries::Vector{Char};\n    diagElements::Vector{Float64}=Float64[],\n    tolerance::Float64=1e-16,\n    classify::Bool=false,\n)","category":"page"},{"location":"eigen/#fermions.ClassifyBasis-Tuple{Vector{Dict{BitVector, Float64}}, Vector{Char}}","page":"Eigen - Eigenfunction Solver and Related Methods","title":"fermions.ClassifyBasis","text":"ClassifyBasis(basisStates)\n\nClassify the set of basis states according to the total occupancy and total magnetisation.\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> ClassifyBasis(basis, ['N', 'Z'])\nDict{Tuple{Int64, Int64}, Vector{Dict{BitVector, Float64}}} with 4 entries:\n  (0, 0)  => [Dict([0, 0]=>1.0)]\n  (1, -1) => [Dict([0, 1]=>1.0)]\n  (1, 1)  => [Dict([1, 0]=>1.0)]\n  (2, 0)  => [Dict([1, 1]=>1.0)]\n\n\n\n\n\n\n","category":"method"},{"location":"eigen/#fermions.TransformState-Tuple{Vector{Float64}, Vector{Dict{BitVector, Float64}}}","page":"Eigen - Eigenfunction Solver and Related Methods","title":"fermions.TransformState","text":"TransformState(vector, basisStates)\n\nGiven a basis {Bi} and a vector {ci}, return the basis representation Σi ci B_i of the vector\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> vector = [0, 0.5, -0.5, 0];\n\njulia> TransformState(vector, basis)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => -0.5\n  [0, 1] => 0.5\n\n\n\n\n\n","category":"method"},{"location":"eigen/#fermions.Spectrum-Tuple{Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Dict{BitVector, Float64}}}","page":"Eigen - Eigenfunction Solver and Related Methods","title":"fermions.Spectrum","text":"Spectrum(operator, basisStates)\n\nReturn eigenvalues and eigenvectors of the hermitian operator in the subspace defined by the basis.\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> operator = [(\"+-\", [1, 2], 1.0), (\"+-\", [2, 1], 1.0)]\n2-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"+-\", [1, 2], 1.0)\n (\"+-\", [2, 1], 1.0)\n\njulia> E, X = Spectrum(operator, basis);\n\njulia> display(E)\n4-element Vector{Float64}:\n -0.9999999999999989\n  0.0\n  0.0\n  1.0\n\njulia> display(X)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([1, 0] => -0.7071067811865475, [0, 1] => 0.7071067811865477)\n Dict([0, 0] => 1.0)\n Dict([1, 1] => 1.0)\n Dict([1, 0] => 0.7071067811865477, [0, 1] => 0.7071067811865475)\n\n\n\n\n\n","category":"method"},{"location":"eigen/#fermions.Spectrum-Tuple{Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Dict{BitVector, Float64}}, Vector{Char}}","page":"Eigen - Eigenfunction Solver and Related Methods","title":"fermions.Spectrum","text":"Spectrum(operator, basisStates)\n\nExtends Spectrum() by making use of symmetries.\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> operator = [(\"+-\", [1, 2], 1.0), (\"+-\", [2, 1], 1.0)]\n2-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"+-\", [1, 2], 1.0)\n (\"+-\", [2, 1], 1.0)\n\njulia> E, X = Spectrum(operator, basis, ['N']; classify=true);\n\njulia> display(X)\nDict{Tuple{Int64}, Vector{Dict{BitVector, Float64}}} with 3 entries:\n  (0,) => [Dict([0, 0]=>1.0)]\n  (2,) => [Dict([1, 1]=>1.0)]\n  (1,) => [Dict([1, 0]=>0.707107, [0, 1]=>-0.707107), Dict([1, 0]=>0.707107, [0, 1]=>0.707107)]\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-Start:-Installation-and-a-Concrete-Example","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"This write-up is designed to show you very quickly how to start using this toolkit. It demonstrates the typical kind of calculations that are possible using the fermions.jl library. ","category":"page"},{"location":"quickstart/#Installation","page":"Quick-Start: Installation and a Concrete Example","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The system must have a running Julia installation in order to use fermions.jl:","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"# install Julia on Unix-ish systems\n$ curl -fsSL https://install.julialang.org | sh\n\n# install Julia on windows\n> winget install julia -s msstore","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Once a running Julia environment is available, start the Julia REPL by running julia from a terminal, and run the following commands to install the fermions.jl library:","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"julia> import Pkg\njulia> Pkg.add(url=\"https://github.com/abhirup-m/fermions.jl\")","category":"page"},{"location":"quickstart/#Defining-our-Model-The-Tight-Binding-Model-in-One-Dimension","page":"Quick-Start: Installation and a Concrete Example","title":"Defining our Model - The Tight-Binding Model in One Dimension","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The model considered here is a prototypical one, involving spinless electrons hopping on a 1D lattice, with open boundary conditions (the electrons cannot hop beyond the left and right edges of the chain).","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"(Image: ) Schematic picture of the model being considered here. Circles represent lattice sites and arrows represent electron hopping processes across sites.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The Hamiltonian of the model is very simple; there are only two kinds of processes - one that starts from a lattice site i and goes to the site next to it (i+1), and another one that goes to the site before it (i-1). In terms of operators, the Hamiltonian can be written as","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"H = sum_i left(c^dagger_i c_i+1 + c^dagger_i+1c_iright)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"In this write-up, we will now show how to accomplish the following:","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Define the above Hamiltonian and diagonalise it to obtain the spectrum.\nAnalyse the ground state and calculate the distribution of particles on the lattice in the ground state.\nCalculate thermal correlation functions such as the local particle density at a non-zero temperature.\nCalculate other useful quantities such as the entanglement of a region of space and the spectral function. ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"This quick-start example is also available as a notebook.","category":"page"},{"location":"quickstart/#Importing-Packages","page":"Quick-Start: Installation and a Concrete Example","title":"Importing Packages","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"using fermions # Importing fermions.jl library\nusing Plots, Measures # Importing tools for plotting\nPlots.theme(:dark)","category":"page"},{"location":"quickstart/#Defining-Basis-States","page":"Quick-Start: Installation and a Concrete Example","title":"Defining Basis States","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Most applications of this libray require us to define a choice of basis states. The most convenient basis for us is the real space basis, consisting of states such [1, 0, 1, 1, ..., 0, 1], where each number in the vector can be 0 or 1, and the i^mathrmth number represents whether the i^mathrmth lattice site is occupied(1) or unoccupied(0). Within the library, we define the basis states using the function BasisStates:","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"basis = fermions.BasisStates(numSites, occupancy)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Here, the first argument numSites is an Int that represents the number of lattice sites that must be taken into account while creating the basis, while the second (optional) argument occupancy is another Int which represents the number of occupied particles in the basis states. For example, if we choose basis = fermions.BasisStates(2, 1), that will return the basis states involving two lattice sites and one electron occupying those sites, leading to the basis [1, 0], [0, 1].","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"numSites = 2 # number of lattice sites\noccupancy = 1\nbasis = fermions.BasisStates(numSites, occupancy) ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"2-element Vector{Dict{BitVector, Float64}}:\n Dict([1, 0] => 1.0)\n Dict([0, 1] => 1.0)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The two basis states show the two possible combinations: [1, 0] is the state with the first site occupied and the second site unoccupied, while [0, 1] has the opposite configuration.","category":"page"},{"location":"quickstart/#Creating-the-Hamiltonian","page":"Quick-Start: Installation and a Concrete Example","title":"Creating the Hamiltonian","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Any general second-quantised Hamiltonian can be represented, while using the library, as a 1D array. In order to explain how to create the Hamiltonian, we will start by giving a very simple example. The (non-Hermitian) Hamiltonian c^dagger_1 c_2 - c^dagger_3 c_4 is represented as","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"H = [\n        (\"+-\", [1, 2], 1.0),\n        (\"+-\", [3, 4], -1.0),\n    ]","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Each tuple (...) within the array represents a term of the full Hamiltonian. The term c^dagger_1 c_2 is represented by the first tuple (\"+-\", [1, 2], 1.0); the string \"+-\" encodes the fact that the operator is a product of a creation operator(+) and an annihilation operator(-), the vector [1,2] indicates that the + and - operators act on the first and second indices within in each basis states, and the third (Float) 1.0 indicates the strength of this term. ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The second tuple (\"+-\", [3, 4], -1.0) can be understood as a representation of the second operator - c^dagger_3 c_4 in the same way.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"# designing the tight-binding Hamiltonian\nfunction TightBindHamiltonian(numSites)\n\n    # define the array of tuples to store all terms in the Hamiltonian \n    hamiltonianTerms = Tuple{String, Vector{Int64}, Float64}[]\n\n    # loop over all lattice sites (skip the end, because we have c^\\dagger_i+1 \n    for i in 1:numSites-1\n\n        # the term c^\\dagger_i c_i+1\n        term1 = (\"+-\", [i, i+1], 1.0)\n\n        # the term c^\\dagger_i+1 c_i\n        term2 = (\"+-\", [i+1, i], 1.0)\n\n        # add both terms to the Hamiltonian\n        push!(hamiltonianTerms, term1)\n        push!(hamiltonianTerms, term2)\n    end\n    return hamiltonianTerms\nend","category":"page"},{"location":"quickstart/#Calculating-Correlations:-Local-Probability-Distribution","page":"Quick-Start: Installation and a Concrete Example","title":"Calculating Correlations: Local Probability Distribution","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"Correlations are expectation values of observable operators, computed in the ground state: langlePsi_mathrmgshat OPsi_mathrmgsrangle. Any such expectation value can be calculated using the function GenCorrelation(state, operator), where state can be one of the eigenstates (where we want to compute the correlation), and operator has to be constructed in the same way as the Hamiltonian.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"As another physically-motivated demonstration, we will now calculate the real-space distribution of the ground state function, which is just the likelyhood of finding the electron at a given point in space. The probablity distribution at the i^mathrmth lattice point is the expectation value ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"langlePsi_mathrmgsc^dagger_i c_i Psi_mathrmgsrangle = langlePsi_mathrmgs hat n_i Psi_mathrmgsrangle","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"where hat n is a shorthand for c^dagger c, and is called the number operator. The object operator for this can therefore be constructed as operator=[(\"n\", [i], 1.0)]. The complete thing is shown below.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"# get basis, Hamiltonian and eigenvectors.\nnumSites = 50\nbasis = fermions.BasisStates(numSites, 1)\nhamiltonian = TightBindHamiltonian(numSites)\neigvals, eigvecs = fermions.Spectrum(hamiltonian, basis)\n\n# Define the local density operator, which is just the number operator n_i at a site i. \n# Within the fermions.jl library, the number operator is represented using \"n\", just as c\n# and c^† are represented using \"-\" and \"+\".\ndensityOperators = [[(\"n\", [i], 1.0)] for i in 1:numSites]\n\n# calculate the expectation value of the local density operator in the ground state \n# and a mid-spectrum state. the expectation value is calculated using an internal \n# function GenCorrelation(state, operator), which returns the quantity <state|operator|state>.\ndistribution_low = [fermions.GenCorrelation(eigvecs[1], operator) for operator in densityOperators]\ndistribution_mid = [fermions.GenCorrelation(eigvecs[div(numSites, 2)], operator) for operator in densityOperators]\n\nPlots.scatter([distribution_low, distribution_mid], thickness_scaling=1.4, linewidth=3, legend=true,\n        xlabel=\"odd lattice sites\", ylabel=\"probability distribution\", labels=[\"ground state\" \"excited state\"], margin=-1mm)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"(Image: )","category":"page"},{"location":"quickstart/#Real-space-Entanglement","page":"Quick-Start: Installation and a Concrete Example","title":"Real-space Entanglement","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"As a second demonstration of the physics, we calculate the entanglement entropy of real space regions. Entanglement entropy is a measure of entanglement, quantifying how much a region of space is \"connected\" to the other regions. The source of the connection is the presence of the hopping term in the hamiltonian; as the electron hops from one end of the system to the other, it carries information with it, leading to non-local connections between distant regions. fermions.jl provides several functions to calculate various entanglement measures such as the von Neumann entropy (vnEntropy()), mutual information (mutInfo) and tripartite information (tripInfo). For this model, we will just calculate the von Neumann entropy of any given lattice site i, through the function call vnEntropy(state, [i]), where state is as usual the ground state, and [i] indicates the set of indices whose entanglement entropy will be calculated. Since we want to calculate the entropy of just the i^mathrmth site, the indices is a singleton set for us. ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"# define regions of space of increasing size\nsubsystemIndices = [[i] for i in 1:numSites]\n\n# calculate entanglement entropy of these regions\nSEE = [fermions.vnEntropy(eigvecs[1], indices) for indices in subsystemIndices]\nPlots.plot(SEE, thickness_scaling=1.4, linewidth=3, legend=false,\n        xlabel=\"lattice site\", ylabel=\"entanglement entropy\", margin=-1mm)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"(Image: )","category":"page"},{"location":"quickstart/#Finite-Temperature-Calculations:-Local-Probability-Distribution-as-a-Function-of-Temperature","page":"Quick-Start: Installation and a Concrete Example","title":"Finite Temperature Calculations: Local Probability Distribution as a Function of Temperature","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"One can also calculate thermal averages using the library. Similar to the GenCorrelation function that computes expectation values in a particular state, the ThermalAverage(eigvecs, eigvals, operator, beta) function accepts the complete set of eigenvectors X_i and eigenvalues varepsilon_i, an operator hat O and an inverse temperature beta beta, and calculates the thermal expectation value ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"sum_i e^-beta varepsilon_ilangle X_i  hat O  X_i rangle","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"In the snippet below, we compute the thermal average of two operators, the probability of occupying the left edge hat n_1, and the probability of occupying the central site hat n_N2.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"# define a range of temperatures to perform calculations at\ninvTempRange = 10 .^ range(-1, 2.5, 20)\n\n# define the operators whose thermal average we wish to calculate\nleftOccOperator = [(\"n\", [1], 1.0)] # occupancy of left edge\ncenterOccOperator = [(\"n\", [div(numSites, 2)], 1.0)] # occupancy of center\n\n# calculate thermal averages over the given range of inverse temperature\nleftOccAverage = [fermions.ThermalAverage(eigvecs, eigvals, leftOccOperator, beta) for beta in invTempRange]\ncenterOccAverage = [fermions.ThermalAverage(eigvecs, eigvals, centerOccOperator, beta) for beta in invTempRange]\n\nPlots.plot(1 ./ invTempRange, [leftOccAverage, centerOccAverage];\n    thickness_scaling=1.5, linewidth=3,\n    xaxis=:log10, xlabel=\"temp. / \\$\\\\Delta E\\$\", ylabel=\"local occupancy\", \n    labels=[\"left edge\" \"center\"], leftmargin=-5mm, bottommargin=-3mm)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"(Image: )","category":"page"},{"location":"quickstart/#Spectral-Function","page":"Quick-Start: Installation and a Concrete Example","title":"Spectral Function","text":"","category":"section"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"As a final demonstration, we show how to calculate the local spectral function for the model. A spectral function A(omega) captures the probability of exciting the ground state of a system into an excited electron with a particular excitation energy omega; a higher value of the spectral function at a particular frequency indicates a higher likelihood of exciting the system by shedding light of that frequency. Formally, the spectral function associated with the excitation operator hat O_1 and the relaxation operator hat O_2 is defined as ","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"A(omega) = -frac1pimathrmImleftmathcalF_omega(langle hat O_2(t)hat O_1(0)rangle)right","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"where mathcalF_omega(cdot) is the Fourier transform.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"The spectral function is calculated using the provided function SpecFunc(eigvecs, eigvals, probe, probeDag, freqArr, broadening), where eigvecs, eigvals constitute the spectrum of the system, probe and probeDag are the excitation and relaxation operators hat O_1 and hat O_2, freqArr is the set of frequency points at which the spectral function must be calculated, and broadening is the width of the Lorentzian that will be used to replace poles. For the snippet below, we have taken the local operators c_N2 and c^dagger_N2 as the excitation and relaxation operators.","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"numSites = 40 # number of lattice sites\n\n# Get basis states for a system with 0, 1 and 2 occupied sites.\n# The ground state will be taken from the 1 occupied site system,\n# but the excitations will take it to the other systems.\nbasis_N = fermions.BasisStates(numSites, 1)\nbasis_Nminus1 = fermions.BasisStates(numSites, 0)\nbasis_Nplus1 = fermions.BasisStates(numSites, 2)\n\n# diagonalise all three systems\ntightBindHam = TightBindHamiltonian(numSites)\neigvals_N, eigvecs_N = fermions.Spectrum(tightBindHam, basis_N)\neigvals_Nminus1, eigvecs_Nminus1 = fermions.Spectrum(tightBindHam, basis_Nminus1)\neigvals_Nplus1, eigvecs_Nplus1 = fermions.Spectrum(tightBindHam, basis_Nplus1)\n\n# define the set of frequency points\nfreqArr = collect(range(-2.5, stop=2.5, step=0.01))\n\n# define the excitation and relaxation operators\nprobe = [(\"-\", [div(numSites, 2)], 1.0)]\nprobeDag = [(\"+\", [div(numSites, 2)], 1.0)]\n\n# get spectral function\nspecfunc = fermions.SpecFunc([eigvals_N; eigvals_Nminus1; eigvals_Nplus1], \n    [eigvecs_N; eigvecs_Nminus1; eigvecs_Nplus1], probe, probeDag, freqArr, 1e-2)\n\np = Plots.plot(freqArr, specfunc, thickness_scaling=1.5, linewidth=2, legend=false, \n    xlabel=\"frequency \\$\\\\omega\\$\", ylabel=\"spectral function\\$\", margin=-2mm)\ndisplay(p)","category":"page"},{"location":"quickstart/","page":"Quick-Start: Installation and a Concrete Example","title":"Quick-Start: Installation and a Concrete Example","text":"(Image: )","category":"page"},{"location":"theory/#Theoretical-Background-Fermions,-Symmetries-and-Second-Quantisation","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"This page lays out some of the theoretical details that have been utilised while developing this toolkit. All these ideas are very rudimentary from the perspective of practising condensed matter physicists, so this section is mostly for the sake of completeness.","category":"page"},{"location":"theory/#A-Brief-explanation-of-second-quantised-operators","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"A Brief explanation of second-quantised operators","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"The entire library is built on the idea of using second-quantisation to study many-body Hamiltonians, so a discussion of that is certainly pertinent. Second quantised operators are a convenient way of writing many-body Hamiltonians. This library is only concerned with electrons; these are particles whose states must be antisymmetric with respect to an exchange of the particles. For example, a state of electrons at positions 1 and 2 has to be 12rangle - 2 1rangle. In order to avoid this clumsy notation, we introduce creation and annihilation operators c^dagger_nu and c_nu, which carry the property of antisymmetry within themselves. The two operators, respectively, create and annihilate an electron in the state described by the quantum number nu, which can be the position or momentum, among others; they satisfy c_1 c_2 = -c_2 c_1, allowing us to write the above complicated state simply as c^dagger_1 c^dagger_20rangle.","category":"page"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"As an example, we wish to design the Hamiltonian of a single electron hopping across a 1D chain of lattice sites labelled as i=1, i=2, i=3 and so on. The system is such that the electron can only hop on to the nearest-neighbour sites starting from any given site: ito i+1, ito i-1. In order to hop from, say, i=1 to i=2, the electron must first be annihilated at the site i=1 and then created at i=2. The creation process is represented by the operator c^dagger_1 (1 representing the site index of the location of the operation), while the annihilation process is represented by c_2, the total process being the product of both process: c^dagger_1 c_2. Of course, the opposite process can also happen - the electron can also hop from i=2 to i=1, so that the total second-quantised Hamiltonian for the dynamics involving sites 1 and 2 is ","category":"page"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"c^dagger_1 c_2 + c^dagger_2 c_1","category":"page"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"Now, the indices 1 and 2 can be represented by any consecutive indices i and i+1, leading to the so-called tight-binding Hamiltonian in 1-dimensions:","category":"page"},{"location":"theory/","page":"Theoretical Background - Fermions, Symmetries and Second Quantisation","title":"Theoretical Background - Fermions, Symmetries and Second Quantisation","text":"H_mathrmTB = sum_i left(c^dagger_i c_i+1 + c^dagger_i+1 c_iright)","category":"page"},{"location":"correlations/#Correlations-Computing-Observables-and-Other-Analyses","page":"Correlations - Computing Observables and Other Analyses","title":"Correlations - Computing Observables and Other Analyses","text":"","category":"section"},{"location":"correlations/","page":"Correlations - Computing Observables and Other Analyses","title":"Correlations - Computing Observables and Other Analyses","text":"GenCorrelation(\n        state::Dict{BitVector,Float64},\n        operator::Vector{Tuple{String,Vector{Int64},Float64}}\n    )\n\nReducedDM(\n        state::Dict{BitVector,Float64},\n        reducingIndices::Vector{Int64};\n        reducingConfigs::Vector{BitVector}=BitVector[]\n    )\n\nVonNEntropy(\n        state::Dict{BitVector,Float64},\n        reducingIndices::Vector{Int64};\n        reducingConfigs::Vector{BitVector}=BitVector[],\n        tolerance=1e-10, schmidtGap=false\n    )\n\nMutInfo(\n    state::Dict{BitVector,Float64},\n    reducingIndices::Tuple{Vector{Int64},Vector{Int64}};\n    reducingConfigs::Tuple{Vector{BitVector},Vector{BitVector}}=(BitVector[], BitVector[])\n)\n\nTripartiteInfo(\n    groundState::Dict{BitVector,Float64},\n    reducingIndices::NTuple{3,Vector{Int64}};\n    reducingConfigs::NTuple{3,Vector{BitVector}}=(BitVector[], BitVector[], BitVector[])\n)\n\nThermalAverage(\n    eigenStates::Vector{Dict{BitVector,Float64}},\n    eigenVals::Vector{Float64},\n    operator::Vector{Tuple{String,Vector{Int64},Float64}},\n    invTemp::Float64,\n)\n\nSpecFunc(\n    eigVals::Vector{Float64},\n    eigVecs::Vector{Dict{BitVector,Float64}},\n    probe::Vector{Tuple{String,Vector{Int64},Float64}},\n    probeDag::Vector{Tuple{String,Vector{Int64},Float64}},\n    freqArray::Vector{Float64},\n    broadening::Float64;\n    gsIndex::Int64=0,\n)\n\nSpecFunc(\n    eigVals::Vector{Float64},\n    eigVecs::Vector{Dict{BitVector,Float64}},\n    probe::Vector{Tuple{String,Vector{Int64},Float64}},\n    probeDag::Vector{Tuple{String,Vector{Int64},Float64}},\n    freqArray::Vector{Float64},\n    broadening::Float64,\n    symmetries::Vector{Char};\n    gsIndex::Int64=0,\n)","category":"page"},{"location":"correlations/#fermions.GenCorrelation-Tuple{Dict{BitVector, Float64}, Vector{Tuple{String, Vector{Int64}, Float64}}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.GenCorrelation","text":"GenCorrelation(state, operator)\n\nCalculate the expectation value ⟨state|operator|state⟩.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0]) => 0.5, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 0.5\n  [0, 1] => -0.5\n\njulia> operator = [(\"+-\", [1, 2], 1.0)]\n1-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"+-\", [1, 2], 1.0)\n\njulia> GenCorrelation(state, operator)\n-0.5\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.ReducedDM-Tuple{Dict{BitVector, Float64}, Vector{Int64}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.ReducedDM","text":"reducedDM(state, reducingIndices)\n\nReduce the density matrix |state⟩⟨state| by tracing over the  indices not specified in reducingIndices.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0]) => 0.5, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 0.5\n  [0, 1] => -0.5\n\njulia> reducedDM(state, [1])\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.VonNEntropy-Tuple{Dict{BitVector, Float64}, Vector{Int64}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.VonNEntropy","text":"VonNEntropy(state, reducingIndices)\n\nCalculate entanglement entropy of the subsystem defined by reducingIndices.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0]) => 0.5, Bool.([0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0] => 0.5\n  [0, 1] => -0.5\n\njulia> VonNEntropy(state, [1])\n0.6931471805599453\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.MutInfo-Tuple{Dict{BitVector, Float64}, Tuple{Vector{Int64}, Vector{Int64}}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.MutInfo","text":"MutInfo(state, reducingIndices)\n\nCalculate mutual information between the subsystems defined by the tuple reducingIndices.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0, 1]) => 0.5, Bool.([0, 1, 0]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [0, 1, 0] => -0.5\n  [1, 0, 1] => 0.5\n\njulia> MutInfo(state, ([1], [2]))\n0.6931471805599453\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.TripartiteInfo-Tuple{Dict{BitVector, Float64}, Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.TripartiteInfo","text":"TripartiteInfo(state, reducingIndices)\n\nCalculate tripartite information between the subsystems defined by the 3-tuple reducingIndices.\n\nExamples\n\njulia> state = Dict(Bool.([1, 0, 1, 0]) => 0.5, Bool.([0, 1, 0, 1]) => -0.5)\nDict{BitVector, Float64} with 2 entries:\n  [1, 0, 1, 0] => 0.5\n  [0, 1, 0, 1] => -0.5\n\njulia> TripartiteInfo(state, ([1], [2], [3]))\n0.6931471805599453\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.ThermalAverage-Tuple{Vector{Dict{BitVector, Float64}}, Vector{Float64}, Vector{Tuple{String, Vector{Int64}, Float64}}, Float64}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.ThermalAverage","text":"ThermalAverage(eigenStates, eigenVals, operator, invTemp)\n\nCalculate the canonical ensemble average of operator at the given inverse temperature for the given spectrum.\n\nExamples\n\njulia> basis = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> eigenStates = BasisStates(2)\n4-element Vector{Dict{BitVector, Float64}}:\n Dict([0, 0] => 1.0)\n Dict([0, 1] => 1.0)\n Dict([1, 0] => 1.0)\n Dict([1, 1] => 1.0)\n\njulia> eigenVals = rand(4)\n4-element Vector{Float64}:\n 0.018726877619070992\n 0.43796674226812815\n 0.7905965730299785\n 0.97571966188274\n\njulia> operator = [(\"n\", [1], 1.0)]\n1-element Vector{Tuple{String, Vector{Int64}, Float64}}:\n (\"n\", [1], 1.0)\n\njulia> ThermalAverage(basis, eigenVals, operator, 1.0)\n0.33797199716422116\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.SpecFunc-Tuple{Vector{Float64}, Vector{Dict{BitVector, Float64}}, Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Float64}, Float64}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.SpecFunc","text":"SpecFunc(eigVals, eigVecs, probe, probeDiag, freqArray, broadening)\n\nCalculate the spectral function for the excitations defined by probe and probeDiag.\n\nExamples\n\njulia> eigenVals = [0., 1., 1.];\n\njulia> eigenStates = Dict{BitVector, Float64}[Dict([1, 0] => 1.0, [0, 1] => 1.0), Dict([1, 1] => 1.0), Dict([0, 0] => 1.0)]\n3-element Vector{Dict{BitVector, Float64}}:\n Dict([1, 0] => 1.0, [0, 1] => 1.0)\n Dict([1, 1] => 1.0)\n Dict([0, 0] => 1.0)\n\njulia> probe = [(\"-\", [1], 1.0)];\n\njulia> probeDag = [(\"+\", [1], 1.0)];\n\njulia> freqArray = collect(range(-2, stop=2, length=10));\n\njulia> SpecFunc(eigenVals, eigenStates, probe, probeDag, freqArray, 1e-2)\n10-element Vector{Float64}:\n 0.011110098865559272\n 0.03392067328129922\n 0.8057354340607891\n 0.09351894323911442\n 0.023221646866030225\n 0.023221646866030225\n 0.09351894323911442\n 0.8057354340607891\n 0.03392067328129922\n 0.011110098865559272\n\n\n\n\n\n","category":"method"},{"location":"correlations/#fermions.SpecFunc-Tuple{Vector{Float64}, Vector{Dict{BitVector, Float64}}, Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Tuple{String, Vector{Int64}, Float64}}, Vector{Float64}, Float64, Vector{Char}}","page":"Correlations - Computing Observables and Other Analyses","title":"fermions.SpecFunc","text":"SpecFunc(eigVals, eigVecs, probe, probeDiag, freqArray, broadening, symmetries)\n\nExtends SpecFunc() by making use of symmetries.\n\nExamples\n\njulia> SpecFunc(eigenVals, eigenStates, probe, probeDag, freqArray, 1e-2, ['N'])\n\n\n\n\n\n","category":"method"},{"location":"#Fermions.jl","page":"Fermions.jl","title":"Fermions.jl","text":"","category":"section"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"A Toolkit for Working with Models of Interacting Electrons","category":"page"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"(Image: )","category":"page"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"Fermions.jl is a toolkit for designing and analysing second-quantised many-particle Hamiltonians of electrons, potentially interacting with each other. The main point in designing this library is to abstract away the detailed task of writing matrices for many-body Hamiltonians and operators (for correlations functions) with large Hilbert spaces; all operators (including Hamiltonians) can be specified using predefined symbols, and the library then provides functions for diagonalising such Hamiltonians and computing observables within the states. (In case you are not accustomed to using second-quantised operators, check this brief explanation.)","category":"page"},{"location":"#Neat-features","page":"Fermions.jl","title":"Neat features","text":"","category":"section"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"Construct many-body operators and states using simple datastructures such as dictionaries and vectors. No need to bother with complicated and abstract classes and their objects.\nHigh-level of freedom in constructing fermionic Hamiltonians. All Hamiltonians that can be represented as a tensor product of 2-dimensional fermionic Fock-space operators can be modelled using fermions.jl.\nUses optimised algorithms that make use of symmetries of the problem. Models with total occupancy conservation and/or total magnetisation conservation can be automatically block-diagonalised.\nProvides a wide range of inbuilt functions for calculating various quantities of physical interest, including spectral functions, static correlations and measures of entanglement. The ability to construct any general correlation function by using fermionic operators further extends the range of possibilities.","category":"page"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"This library was borne out of a need to numerically construct and solve fermionic Hamiltonians in the course of my doctoral research. While there are similar julia libraries such as Marco-Di-Tullio/Fermionic.jl and qojulia/QuantumOptics.jl, fermions.jl is much more intuitive since it works directly on predefined basis states and allows defining arbitrary fermionic operators and quantum mechanical states. There is no need to interact with complicated and abstract classes and objects in order to use this library; everything is defined purely in terms of simple datastructures such as dictionaries, vectors and tuples. This makes the entire process transparent and intuitive.","category":"page"},{"location":"#Will-this-be-useful-for-me?","page":"Fermions.jl","title":"Will this be useful for me?","text":"","category":"section"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"You might find this library useful if you spend a lot of time studying Hamiltonian models of fermionic or spin-1/2 systems, particularly ones that cannot be solved analytically, or use a similar library in another language (QuTip in python, for example), but want to migrate to Julia. You will not find this useful if you mostly work with bosonic systems and open quantum systems, or work in the thermodynamic limit (using methods like quantum Monte Carlo, numerical RG).","category":"page"},{"location":"#Documentation-Outline","page":"Fermions.jl","title":"Documentation Outline","text":"","category":"section"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"Pages = [\"quickstart.md\", \"base.md\", \"eigen.md\", \"correlations.md\", \"theory.md\"]\nDepth = 1","category":"page"},{"location":"","page":"Fermions.jl","title":"Fermions.jl","text":"Feedback and contributions are always welcome!","category":"page"}]
}
